---
title: "In-class Exercise 6"
author: "Emily Aurelia"
format:
  html:
    toc-depth: 4
execute: 
  warning: false #to remove the warning in the webpage
  freeze: true #to keep the codes that are unchanged to not re-render
  message: false #to remove the message in the webpage
date: "`r Sys.Date()`"
---

# Library import

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, ClustGeo, ggpubr, cluster, factoextra, NbClust, sp, heatmaply, corrplot, psych, GGally)
#gdal already retired
```


# Data import

```{r}
shan_sf <- st_read(dsn = "data/geospatial", layer="myanmar_township_boundaries") |> filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) |> 
  select(c(2:7)) #make the data frame smaller to increase computational speed and less memory usage

shan_sf #see if it is an sf object
class(shan_sf) #check the class of the object
```


```{r}
ict <- read.csv("data/aspatial/Shan-ICT.csv")
summary(ict)
```
```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total.households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total.households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land.line.phone`/`Total.households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile.phone`/`Total.households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total.households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet.at.home`/`Total.households`*1000) %>%
  rename(`DT_PCODE` =`District.Pcode`,`DT`=`District.Name`,
         `TS_PCODE`=`Township.Pcode`, `TS`=`Township.Name`,
         `TT_HOUSEHOLDS`=`Total.households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land.line.phone`, `MPHONE`=`Mobile.phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet.at.home`) 
```

# EDA

```{r}
#build a lot of histograms together
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2) # to combine the graphs together
```


```{r}
#| eval: false
shan_sf <- left_join(shan_sf, ict_derived, by=c("TS_PCODE" = "TS_PCODE")) #in reality you dont need the by statement as the name of the column is the same
# if you want to combine the data, it is recommended to do the spatial in the beginning for left_join

write_rds(shan_sf, 'data/rds/shan_sf.rds')
```

```{r}
shan_sf <- read_rds('data/rds/shan_sf.rds')
```


```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

```{r}
#prepare data for cluster analysis
cluster_vars <- shan_sf |>
  st_set_geometry(NULL) |>
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")

head(cluster_vars, 10)
```

```{r}
#change row name to the township name
row.names(cluster_vars) <- cluster_vars$TS.x
head(cluster_vars, 10)
```
```{r}
shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```
```{r}
#min-max standardization
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

```{r}
#z-score standardization
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```
```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

# Proximity matrix

```{r}
proxmat <- dist(shan_ict, method = "euclidean")
#methods can be changed to other types provided in the documentation
#type is list
proxmat
#will retain the row names of the data frame
```
```{r}
hclust_ward <- hclust(proxmat, method = "ward.D")
#other methods are available
```

```{r}
plot(hclust_ward, cex = 0.6)
#the cex is the size of the text
```

# Determine optimal clusters

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

```{r}
fviz_gap_stat(gap_stat)
```
The graph goes down adn the up then down and up again, so choose the highest optimization value on the first bump, which is 5 or 6 in this case. From the statistic, the cluster 6 has a higher optimization, so that we can use cluster 6. see the `gap` value in the statistic

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 6, #number of cluster that you want to stop at
            border = 2:5)
```

try going for a 10 cluster

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 10, #number of cluster that you want to stop at
            border = 2:5)
```

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>% # use cbind because this one is just a list, and no unique identifier, but no sorting
  rename(`CLUSTER`=`as.matrix.groups.`)
```

```{r}
qtm(shan_sf_cluster, "CLUSTER")
# the cluster number is a factor, so the cluster is nominal
```
dont need to use the as_Spatial() function because the latest version of spdep accepts sf object

```{r}
shan.nb <- poly2nb(shan_sf)
summary(shan.nb)
```
# plot
```{r}
plot(st_geometry(shan_sf), # st_geometry to output only one layer of geometry, without the st_geometry--> then will plot the different columns; this is for the map 
     border=grey(.5))

pts<- st_coordinates(st_centroid(shan_sf))
plot(shan.nb, #give the edge
     pts, #give the points
     col="blue", 
     add=TRUE)
```


